import { NextResponse } from 'next/server';
import { fetchPrompts } from '@/services/notionService';
import fs from 'fs/promises';
import path from 'path';

export async function POST() {
  try {
    const prompts = await fetchPrompts();
    
    // Group prompts by type
    const systemMessages: { [key: string]: string } = {};
    const templates: { [key: string]: string } = {};
    
    prompts.forEach(prompt => {
      if (prompt.type.startsWith('System Message')) {
        const type = prompt.type.replace('System Message - ', '');
        systemMessages[type] = prompt.content;
      } else {
        templates[prompt.type] = prompt.content;
      }
    });

    // Generate the new prompts.ts file content
    const fileContent = `/**
 * System prompts and templates used throughout the application
 * This file is automatically generated from Notion. Do not edit manually.
 * Last updated: ${new Date().toISOString()}
 */

// System messages for different AI models
export const SYSTEM_MESSAGES = {
${Object.entries(systemMessages)
  .map(([key, value]) => `  ${key}: '${value.replace(/'/g, "\\'")}',`)
  .join('\n')}
};

// Topic generation prompt template
export const TOPIC_GENERATION_PROMPT = (industry: string) => 
  \`${templates['Topic Generation']?.replace(/\`/g, '\\`')}\`;

// Article search prompt template
export const ARTICLE_SEARCH_PROMPT = (topic: string) =>
  \`${templates['Article Search']?.replace(/\`/g, '\\`')}\`;

// LinkedIn post generation prompt template
export const POST_GENERATION_PROMPT = (article: any, industry: string, topic: string) =>
  \`${templates['Post Generation']?.replace(/\`/g, '\\`')}\`;
`;

    // Write the new content to prompts.ts
    const promptsPath = path.join(process.cwd(), 'src/config/prompts.ts');
    await fs.writeFile(promptsPath, fileContent, 'utf-8');

    return NextResponse.json({ 
      success: true, 
      message: 'Successfully updated prompts.ts' 
    });
  } catch (error: any) {
    console.error('Error updating prompts:', error);
    return NextResponse.json({ 
      success: false, 
      error: error.message 
    }, { status: 500 });
  }
} 